# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `simple_xlsx_reader` gem.
# Please instead update this file by running `bin/tapioca gem simple_xlsx_reader`.


# source://simple_xlsx_reader//lib/simple_xlsx_reader/version.rb#1
module SimpleXlsxReader
  class << self
    # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#49
    def configuration; end

    # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#55
    def open(file_path); end

    # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#59
    def parse(string_or_io); end
  end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#20
class SimpleXlsxReader::CellLoadError < ::StandardError; end

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#63
class SimpleXlsxReader::Document
  # @return [Document] a new instance of Document
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#66
  def initialize(legacy_file_path = T.unsafe(nil), file_path: T.unsafe(nil), string_or_io: T.unsafe(nil)); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#73
  def sheets; end

  # Returns the value of attribute string_or_io.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#64
  def string_or_io; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#77
  def to_hash; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#81
  def xml; end
end

# For internal use; translates source xml to Sheet objects.
#
# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#162
class SimpleXlsxReader::Document::Mapper < ::Struct
  # Returns the base_date from which to calculate dates.
  # Defaults to 1900 (minus two days due to excel quirk), but use 1904 if
  # it's set in the Workbook's workbookPr.
  # http://msdn.microsoft.com/en-us/library/ff530155(v=office.12).aspx
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#474
  def base_date; end

  # formula fits an exponential factorial function of the form:
  # 'A'   = 1
  # 'B'   = 2
  # 'Z'   = 26
  # 'AA'  = 26 * 1  + 1
  # 'AZ'  = 26 * 1  + 26
  # 'BA'  = 26 * 2  + 1
  # 'ZA'  = 26 * 26 + 1
  # 'ZZ'  = 26 * 26 + 26
  # 'AAA' = 26 * 26 * 1 + 26 * 1  + 1
  # 'AAZ' = 26 * 26 * 1 + 26 * 1  + 26
  # 'ABA' = 26 * 26 * 1 + 26 * 2  + 1
  # 'BZA' = 26 * 26 * 2 + 26 * 26 + 1
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#292
  def column_letter_to_number(column_letter); end

  # Map of (numFmtId >= 164) (custom styles) to our best guess at the type
  # ex. {164 => :date_time}
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#348
  def custom_style_types; end

  # This is the least deterministic part of reading xlsx files. Due to
  # custom styles, you can't know for sure when a date is a date other than
  # looking at its format and gessing. It's not impossible to guess right,
  # though.
  #
  # http://stackoverflow.com/questions/4948998/determining-if-an-xlsx-cell-is-date-formatted-for-excel-2007-spreadsheets
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#366
  def determine_custom_style_type(string); end

  # Returns the last column name, ex. 'E'
  #
  # Note that excel writes a '/worksheet/dimension' node we can get the
  # last cell from, but some libs (ex. simple_xlsx_writer) don't record
  # this. In that case, we assume the data is of uniform column length
  # and check the column name of the last header row. Obviously this isn't
  # the most robust strategy, but it likely fits 99% of use cases
  # considering it's not a problem with actual excel docs.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#262
  def last_cell_label(xsheet); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#166
  def load_sheets; end

  # returns the numFmtId value if it's available
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#323
  def num_fmt_id(xstyle); end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#184
  def parse_sheet(sheet_name, xsheet, xrels); end

  # For performance reasons, excel uses an optional SpreadsheetML feature
  # that puts all strings in a separate xml file, and then references
  # them by their index in that file.
  #
  # http://msdn.microsoft.com/en-us/library/office/gg278314.aspx
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#526
  def shared_strings; end

  # Returns dimensions (1-indexed)
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#274
  def sheet_dimensions(xsheet); end

  # Table of contents for the sheets, ex. {'Authors' => 0, ...}
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#173
  def sheet_toc; end

  # Finds the type we think a style is; For example, fmtId 14 is a date
  # style, so this would return :date.
  #
  # Note, custom styles usually (are supposed to?) have a numFmtId >= 164,
  # but in practice can sometimes be simply out of the usual "Any Language"
  # id range that goes up to 49. For example, I have seen a numFmtId of
  # 59 specified as a date. In Thai, 59 is a number format, so this seems
  # like a bad idea, but we try to be flexible and just go with it.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#339
  def style_type_by_num_fmt_id(id); end

  # Excel doesn't record types for some cells, only its display style, so
  # we have to back out the type from that style.
  #
  # Some of these styles can be determined from a known set (see NumFmtMap),
  # while others are 'custom' and we have to make a best guess.
  #
  # This is the array of types corresponding to the styles a spreadsheet
  # uses, and includes both the known style types and the custom styles.
  #
  # Note that the xml sheet cells that use this don't reference the
  # numFmtId, but instead the array index of a style in the stored list of
  # only the styles used in the spreadsheet (which can be either known or
  # custom). Hence this style types array, rather than a map of numFmtId to
  # type.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#316
  def style_types; end

  class << self
    # The heart of typecasting. The ruby type is determined either explicitly
    # from the cell xml or implicitly from the cell style, and this
    # method expects that work to have been done already. This, then,
    # takes the type we determined it to be and casts the cell value
    # to that type.
    #
    # types:
    # - s: shared string (see #shared_string)
    # - n: number (cast to a float)
    # - b: boolean
    # - str: string
    # - inlineStr: string
    # - ruby symbol: for when type has been determined by style
    #
    # options:
    # - shared_strings: needed for 's' (shared string) type
    #
    # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#393
    def cast(value, type, style, options = T.unsafe(nil)); end
  end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#163
SimpleXlsxReader::Document::Mapper::DATE_SYSTEM_1900 = T.let(T.unsafe(nil), Date)

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#164
SimpleXlsxReader::Document::Mapper::DATE_SYSTEM_1904 = T.let(T.unsafe(nil), Date)

# Map of non-custom numFmtId to casting symbol
#
# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#486
SimpleXlsxReader::Document::Mapper::NumFmtMap = T.let(T.unsafe(nil), Hash)

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#85
class SimpleXlsxReader::Document::Sheet < ::Struct
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#90
  def data; end

  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#86
  def headers; end

  # Load errors will be a hash of the form:
  # {
  #   [rownum, colnum] => '[error]'
  # }
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#98
  def load_errors; end
end

# For internal use; stores source xml in nokogiri documents
#
# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#105
class SimpleXlsxReader::Document::Xml
  # Returns the value of attribute shared_strings.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def shared_strings; end

  # Sets the attribute shared_strings
  #
  # @param value the value to set the attribute shared_strings to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def shared_strings=(_arg0); end

  # Returns the value of attribute sheet_rels.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def sheet_rels; end

  # Sets the attribute sheet_rels
  #
  # @param value the value to set the attribute sheet_rels to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def sheet_rels=(_arg0); end

  # Returns the value of attribute sheets.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def sheets; end

  # Sets the attribute sheets
  #
  # @param value the value to set the attribute sheets to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def sheets=(_arg0); end

  # Returns the value of attribute styles.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def styles; end

  # Sets the attribute styles
  #
  # @param value the value to set the attribute styles to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def styles=(_arg0); end

  # Returns the value of attribute workbook.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def workbook; end

  # Sets the attribute workbook
  #
  # @param value the value to set the attribute workbook to.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#106
  def workbook=(_arg0); end

  class << self
    # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#108
    def load(string_or_io); end
  end
end

# We support hyperlinks as a "type" even though they're technically
# represented either as a function or an external reference in the xlsx spec.
#
# Since having hyperlink data in our sheet usually means we might want to do
# something primarily with the URL (store it in the database, download it, etc),
# we go through extra effort to parse the function or follow the reference
# to represent the hyperlink primarily as a URL. However, maybe we do want
# the hyperlink "friendly name" part (as MS calls it), so here we've subclassed
# string to tack on the friendly name. This means 80% of us that just want
# the URL value will have to do nothing extra, but the 20% that might want the
# friendly name can access it.
#
# Note, by default, the value we would get by just asking the cell would
# be the "friendly name" and *not* the URL, which is tucked away in the
# function definition or a separate "relationships" meta-document.
#
# See MS documentation on the HYPERLINK function for some background:
# https://support.office.com/en-us/article/HYPERLINK-function-333c7ce6-c5ae-4164-9c47-7de9b76f577f
#
# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#40
class SimpleXlsxReader::Hyperlink < ::String
  # @return [Hyperlink] a new instance of Hyperlink
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#43
  def initialize(url, friendly_name = T.unsafe(nil)); end

  # Returns the value of attribute friendly_name.
  #
  # source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#41
  def friendly_name; end
end

# source://simple_xlsx_reader//lib/simple_xlsx_reader/version.rb#2
SimpleXlsxReader::VERSION = T.let(T.unsafe(nil), String)

# source://simple_xlsx_reader//lib/simple_xlsx_reader.rb#16
SimpleXlsxReader::Zip = Zip::File
